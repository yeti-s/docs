---
title: '2. 미로 탈출 명령어'
description: '2023 KAKAO BLIND RECRUITMENT '
---

import BackgroundText from '@content/components/BackgroundText'
import TestInfo from './components/TestInfo'

<TestInfo url='https://school.programmers.co.kr/learn/courses/30/lessons/150365' level={3} solved={true}></TestInfo>

# 문제 분석

미로를 탈출하는 규칙은 아래와 같아요.  
1. <BackgroundText>n x m</BackgroundText> 격자 미로에서 당신은 <BackgroundText>(x, y)</BackgroundText>에서 출발해 <BackgroundText>(r, c)</BackgroundText>로 탈출해야 합니다.
2. 단 <BackgroundText>(x, y)</BackgroundText>에서 <BackgroundText>(r, c)</BackgroundText>까지 이동하는 거리가 총 <BackgroundText>k</BackgroundText>여야 해요.
3. 이때, <BackgroundText>(x, y)</BackgroundText>와 <BackgroundText>(r, c)</BackgroundText>를 포함해, 같은 격자를 두 번 이상 방문해도 됩니다. 

위 과정에서 이동한 경로를 아래와 같은 문자열로 바꾸어 저장할 거예요.
* l: 왼쪽으로 한 칸 이동
* r: 오른쪽으로 한 칸 이동
* u: 위쪽으로 한 칸 이동
* d: 아래쪽으로 한 칸 이동

이 때 이동한 경로를 문자열로 표시한 것 중 사전 순으로 가장 빠른 경로로 탈출한 것을 선택할 거예요.  
예를 들어 <BackgroundText>3 x 4</BackgroundText> 격자 미로에 <BackgroundText>(x, y)</BackgroundText>에서 출발하여 <BackgroundText>(r, c)</BackgroundText>까지 갈 때 <BackgroundText>k=5</BackgroundText>라면 아래와 같은 문자열이 생성됩니다.

* lldud
* ulldd
* rdlll
* dllrl
* dllud
* ...

이때 dllrl이 사전 순으로 가장 빠른 경로로 탈출하는 경우네요.  
만약 위 조건에서 탈출할 수 없다면 <BackgroundText>"impossible"</BackgroundText>을 반환합니다.

이 문제는 출발점과 도착점 사이 거리보다 k가 클 경우 일부러 반복되는 움직임을 만들어야 합니다.
만약 한번 위로 간다면 한번은 아래로, 한번 왼쪽으로 간다면 한번은 오른쪽으로 움직이는 것과 같이 의미 없는 움직임 말이죠.
따라서 '거리 - k'가 짝수가 되어야 의미 없는 움직임을 해도 다시 돌아올 수 있어요.

또한 움직임에는 'd > l > r > u' 순서로 우선순위가 부여됩니다.
그렇기에 우리는 목표 지점으로 가거나, 의미없는 움직임을 만들려면 최대한 아래쪽으로 우선적으로 이동하는 것이 포인트네요.

# 풀이

우리는 먼저 불가능한 경우를 제거해볼 거예요.
위에서 언급한대로 '거리 - k'가 홀수 인 경우를 말이죠.

```python
def solution(n, m, x, y, r, c, k):
    answer = ''

    l1_dist = abs(x-r) + abs(y-c)
    if l1_dist > k or (k - l1_dist) % 2 == 1:
        return 'impossible'
    
    ...
```
이동해야 하는 거리, L1 distance를 구한 후 k와 비교를 해 홀수가 되는 애들을 걸러주었어요.

이제 우리는 의미 없는 움직임을 할지, 목표 지점으로 갈지 정해야 해요.
만약 목표 지점까지 거리가 k보다 크면 의미 없는 움직임을 해도 된다는 이야기죠.
이런 움직임이 목표 지점으로 가는 루트라면 어떨까요?
의미 없는 움직임을 한번 더 할 수 있다는 소리겠네요.
뭐 큰 의미는 없어요.
우리는 그저 탈출 루트와 겹치던 말던 우선순위를 따라 의미 없는 움직임을 하는 것입니다.
k와 목표 지점까지 거리가 같아질 때 까지!
그리고 같아질 때 우리는 목표 지점을 향해 이동하는 것으로 알고리즘을 완성할 수 있겠어요. 

```python
def solution(n, m, x, y, r, c, k):
    ...
    while k > 0:
        l1_dist = abs(x-r) + abs(y-c)
        if k > l1_dist:
            if x < n:
                x += 1
                answer += 'd'
            elif y > 1:
                y -= 1
                answer += 'l'
            elif y < m:
                y += 1
                answer += 'r'
            elif x > 1:
                x -= 1
                answer += 'u'
        # find route
        else:
            if x < r:
                x += 1
                answer += 'd'
            elif y > c:
                y -= 1
                answer += 'l'
            elif y < c:
                y += 1
                answer += 'r'
            elif x > r:
                x -= 1
                answer += 'u'
        k -= 1

    retun answer
```

거리와 k를 계속해서 갱신하여 의미 없는 움직임을 할지, 탈출구를 향해 갈지 결정을 반복하는 것이에요.
물론 우선순위에 따라 어느 곳을 먼저 갈지 결정을 해 주고요.
문제가 생각보다 간단하네요.