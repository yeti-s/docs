"use strict";(self.webpackChunkyeti_docs=self.webpackChunkyeti_docs||[]).push([[861],{3832:function(e,n,t){var a=t(4316),l=(t(7294),t(917));const r=(0,a.Z)("code",{target:"e1h9msy90"})({name:"15yct12",styles:"display:block;width:100%;padding:0.2rem 0.4rem 0rem;color:var(--comment-color)"});n.Z=e=>{let{children:n}=e;return(0,l.tZ)(r,null,n)}},2208:function(e,n,t){t.r(n),t.d(n,{default:function(){return T}});var a=t(1151),l=t(7294),r=t(3832);function i(e){const n=Object.assign({p:"p",code:"code",span:"span",h1:"h1",h3:"h3",ul:"ul",li:"li",pre:"pre",math:"math",semantics:"semantics",mrow:"mrow",mo:"mo",annotation:"annotation"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.p,null,"우리는 보통 훈련 데이터셋으로 부터 만들어진 고정된 크기의 vocabulary를 사용합니다.\r\n테스트 단계에서 나오는 새로운 단어는 [UNK] 토큰으로 할당되죠.\r\n많은 언어들은 복잡한 형태를 띄고있어 한정된 vocabulary는 언어를 더 깊게 이해하지 못하게 해요."),"\n",l.createElement(r.Z,null,l.createElement(n.p,null,"밥을, 밥이, 밥의 등과 같은 조사의 영향을 받아 여러 형태를 가짐")),"\n",l.createElement(n.p,null,"따라서 단어를 더 작은 단위로 나누어 처리하는 ",l.createElement(n.code,null,"subword modeling")," 이용하고는 했어요.\r\n현재에도 훈련, 테스트때 각 단어가 subword로 나누어져 학습되고 있죠.\r\n앞서 다루었던 ",l.createElement(n.code,null,"byte-pair encodig"),"은 아주 간단하고 효과적인 subword vocabulary를 정의하는 전략이에요.\r\n텍스트 데이터에서 가장 흔한 문자 조합을 찾아 점진적으로 subword vocabulary를 구축합니다.\r\n흔한 단어들은 subword가 되고 자주 등장하지 않은 단어는 분리되어 subword의 구성요소가 될거예요."),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 704px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/a6f3a2c034b050b5bd5de1f032710b7f/02cd5/00.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 28.977272727272723%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABP0lEQVR42lWQyW7CMBCG8/7vwanLgR7aK0icEG0FTVUVEkgQWYmzODiLnfwdmwq1lkYznhl/nn8s/DlRFMP3/dtdDYPxpzCE67pwHAe2bYMxdu1PEmx3O2w2G3DOTc7yigoRv0ApiSPFuWhuwPQiMIwjPFai0Hn6QMqe3IBxGHGYz1CnKfVQSakr0MlKsEsD2XU4VTUOeYVODf+B9JFXcEiKhVTQ1ZGgn/d34GFgekeqGaCeLiRQ0zQIyNtxBp8A+iS1MI2HvMR7kGIdpfhKGaqu10Q40yckr28IZnPEyyUykm59nws4WYFGCDOhjkUvjZlVkJ49AT+iM9ZhCkbS9ZRSSrgPjwgXC2wnE6i2hSKGdSw5YnrYkeSy7Q1wTztzWIGQ1+hJfi5akzuSbF3fkbU0pf/8gni1wn46xa9u/ABdCMaTq4UPpwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="00"\n        title=""\n        src="/static/a6f3a2c034b050b5bd5de1f032710b7f/5ebd7/00.png"\n        srcset="/static/a6f3a2c034b050b5bd5de1f032710b7f/06437/00.png 176w,\n/static/a6f3a2c034b050b5bd5de1f032710b7f/ba1c3/00.png 352w,\n/static/a6f3a2c034b050b5bd5de1f032710b7f/5ebd7/00.png 704w,\n/static/a6f3a2c034b050b5bd5de1f032710b7f/02cd5/00.png 821w"\n        sizes="(max-width: 704px) 100vw, 704px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),"\n",l.createElement(n.p,null,"하지만 단어의 완벽한 의미는 문맥에서 옵니다.\r\n동일한 단어라고 해도 문맥을 보고 여러 의미중 정확히 어떤 의미로 사용되었는지 알 수 있는 것이죠."),"\n",l.createElement(n.h1,{id:"pretraining"},"Pretraining"),"\n",l.createElement(n.p,null,"초반에는 사전학습된 word embedding만을 이용하여 훈련중에 문맥에 대한 정보와 합치는 형태로 학습을 진행했습니다.\r\n그래서 downstream task가 문맥을 충분히 알려줄 수 있을 만큼 충분히 효율적이어야 했죠.\r\n즉 word embedding 부분만 사전학습된 상태로 모델 학습을 진행했습니다."),"\n",l.createElement(n.p,null,"최근에는 모든 파라미터가 사전학습된 상태로 시작합니다.\r\n보통 입력의 일부를 숨긴 후, 해당 부분을 모델이 재구성하는 방식으로 사전학습이 진행되죠.\r\n이러한 방식의 사전학습이 언어의 강력한 표현을 구축하는 데 효과적이고, 모델의 초기화 및 언어에 대한 확률 분포를 생성하는데 효과적입니다."),"\n",l.createElement(n.p,null,"그렇기에 최근에는 대규모의 텍스트로 사전학습된 모델을 이용하여 각 작업에 맞도록 fine-tuning하는 형식으로 진행됩니다.\r\n사전학습된 모델은 fine-tuning 단계에서 좋은 출발점을 가지고 시작하는 것이죠.\r\n또한 사전학습된 파라미터 근처의 fine-tuning의 local minima가 꽤 좋은 일반화 성능을 보이고는 합니다."),"\n",l.createElement(n.h1,{id:"three-ways-of-pretraining"},"Three ways of pretraining"),"\n",l.createElement(n.p,null,"사전학습 방식은 모델 구조에 따라 영향을 받습니다."),"\n",l.createElement(n.h3,{id:"encoder-pretraining"},"Encoder pretraining"),"\n",l.createElement(n.p,null,"인코더는 내용의 양방향 정보를 모두 가지고 있어요.\r\n그래서 이전 시점의 정보를 보고 문장을 생성해내는 language modeling이 불가능합니다.\r\n그래서 입력중 일부를 [MASK] 토큰으로 만든 후 이를 예측하는 방식으로 사전학습을 진행하죠.\r\n이를 ",l.createElement(n.code,null,"Masked LM"),"이라고 합니다."),"\n",l.createElement(n.p,null,"대표적인 인코더 모델 BERT의 Masked LM 과정은 다음과 같아요.\r\n임의의 15% 토큰에 대한 예측을 진행할거예요."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"예측을 진행할 단어의 80%를 masking합니다."),"\n",l.createElement(n.li,null,"예측을 진행할 단어의 10%는 다른 임의의 토큰으로 교체합니다."),"\n",l.createElement(n.li,null,"남은 10%는 변경하지 않고 그대로 둡니다. (예측은 진행합니다!)"),"\n"),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 437px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/c8629bd8b5ead8fe286ec24755751cbf/5a428/01.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 66.47727272727273%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACLklEQVR42oWTaU8TURSG+ZVCiQuSIH5B4c/oR/0JaqK2tA1LJGGxtFBZSss+07IMQ2fr7PN4ZijYxIpvcnLvuffc9yz3nJFmW2Xr6JAD9ZzdsxO2T444v74iReD71NZW+fljGbPbZb++jWUY3GNvq8ba0gLa5UWmJ0nCSBzHhFFEJGsqiezP/Ji8AyWR70bIF81mwYdPmsW8E1NyyaRgRXy+ssjbCSfBnZMRBhD31w9deNqG6Q5MtRNetiwmWjYTTYPnjS4vDkzRLbmLeX0ptiq804cQJv31oxC+ErI5yeRNJ2G8XGP02yqj+TXGCuuMl6qM5deZUQLmhHBanL//H+F0n3BWHrztBBnRs+UdcoUNcsUKM2qQ3c1e3NkOJRxMOSdpTInhZDuVmFz9itz2BU8qCuO/rplUk+xuSjLIKcnjKauhfIYZUTACyh58NTyWIijaPotS/AU3pOxELLoJZcuj1IPTYZ8yCM91cSwTTANfOYeew620UxIGXLcVDNkbmsbx/i5ur9ePKPk3oeP5mPIgXFkhni+SNBps1Ovouk6lWmWjssnefoNiqYxp23/6kEcQBgE3uv6gp2SR9Ok9ArnvSsMP4lFCWzz7nvegm6ZJOgj3SMntfnRDCdOQbbdHz/ewpS7arU4sZ5bsPYlGkwgdqa0b+PhhKOdOZueI0/TtX4Tp6NVkrreOD9mRuW511Ix886iZzXc65zunxzL3CsqNRvWwldnV5TyK70rxG7NAxAYiXqUUAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="01"\n        title=""\n        src="/static/c8629bd8b5ead8fe286ec24755751cbf/5a428/01.png"\n        srcset="/static/c8629bd8b5ead8fe286ec24755751cbf/06437/01.png 176w,\n/static/c8629bd8b5ead8fe286ec24755751cbf/ba1c3/01.png 352w,\n/static/c8629bd8b5ead8fe286ec24755751cbf/5a428/01.png 437w"\n        sizes="(max-width: 437px) 100vw, 437px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),"\n",l.createElement(n.p,null,"BERT는 두 개의 내용이 연속되는 텍스트를 입력으로 사용하였어요.\r\n그래서 하나의 텍스트가 또 다른 텍스트와 연결된 문장인지 혹은 임의로 선택된 문장인지 예측하는 ",l.createElement(n.code,null,"next sentence prediction")," 방식도 사용했죠.\r\n그런데 나중에 밝혀진 바로는 next sentence prediction 방식은 불필요하다는 것이 밝혀졌네요."),"\n",l.createElement(n.p,null,"하지만 인코더를 사전학습시키는 위와 같은 방식은 한번에 한 단어를 생성하는 생성형 방식과 적합하지 않습니다."),"\n",l.createElement(n.h3,{id:"decoder-pretraining"},"Decoder pretraining"),"\n",l.createElement(n.p,null,"기본적으로 seq2seq의 디코더와 비슷한 방식으로 사전학습을 진행합니다.\r\nFine-tuning을 진행하며 출력이 classifier에 의해 결정되는 부분이 학습되는 방식이죠."),"\n",l.createElement(n.h3,{id:"encoder-decoder-pretraining"},"Encoder-Decoder pretraining"),"\n",l.createElement(n.p,null,"인코더 부분은 양방향 문맥에 대한 정보를 얻을 수 있고, 디코더 부분은 language modeling을 통한 생성이 가능합니다.\r\n여기서 ",l.createElement(n.code,null,"span corruption"),"이라는 방식이 꽤 좋은 성능을 낸다는 것을 확인했어요.\r\n이는 입력의 일부 단어를 제거하고 디코더에서 제거된 단어를 생성해내는 방식으로 사전학습을 진행하죠."),"\n",l.createElement(n.h1,{id:"very-large-language-model"},"Very large language model"),"\n",l.createElement(n.p,null,"추가로 GPT-3와 같은 초거대 언어 모댈은 추가적인 학습 없이도 컨텍스트 내에서 제공된 예시들로부터 작업을 잘 수행하는 것을 보여줍니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"# input\r\nthanks -> merci\r\nhello -> bonjour\r\nmint -> menthe\r\notter -> ?\r\n\r\n# output\r\nloutre\n")),"\n",l.createElement(n.p,null,"또한 LLM을 학습시키는 비용은 파라미터 수 ",l.createElement(n.span,{className:"math math-inline"},l.createElement(n.span,{className:"katex"},l.createElement(n.span,{className:"katex-mathml"},l.createElement(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(n.semantics,null,l.createElement(n.mrow,null,l.createElement(n.mo,null,"×")),l.createElement(n.annotation,{encoding:"application/x-tex"},"\\times")))),l.createElement(n.span,{className:"katex-html","aria-hidden":"true"},l.createElement(n.span,{className:"base"},l.createElement(n.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),l.createElement(n.span,{className:"mord"},"×")))))," 토큰 수 입니다.\r\n적절한 파라미터 크기에 맞는 적절한 토큰 수를 이용한 학습을 진행하여야 좋은 성능의 모델을 만들 수 있어요."))}var s=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?l.createElement(n,e,l.createElement(i,e)):i(e)},o=t(4316),d=t(1840),c=t(7821),m=t(2654),p=t(4111),g=t(2726),b=t(4480),u=t(2818),h=t(9213),w=t(7213),f=t(9265),A=t(9601),y=t(3071),E=t(6097),v=t(6782),Z=t(4891),k=t(3387),x=t(917);const j=e=>{let{data:{mdx:n,file:t},children:r}=e;const i=(0,b.sJ)((0,u.cp)(u.eE,!1)),s=(0,b.sJ)((0,u.cp)(u.rf,!1)),o=(0,b.Zl)((0,u.cp)(u.Cy,n.tableOfContents.items));return(0,l.useEffect)((()=>{o(n.tableOfContents.items)}),[n]),(0,x.tZ)(d.Z,null,(0,x.tZ)(N,null,(0,x.tZ)(p.Z,null)),(0,x.tZ)(z,null,(0,x.tZ)(C,{className:"navigation",isNavOpened:s},(0,x.tZ)(M,{className:"hide_scroll"},(0,x.tZ)(c.Z,null))),(0,x.tZ)(P,{isNavOpened:s},(0,x.tZ)(O,{isWide:i},(0,x.tZ)(g.Z,{title:n.frontmatter.title,modifiedTime:t.modifiedTime}),(0,x.tZ)(a.Zo,{components:{p:w.Z,h1:f.H1,h2:f.H2,h3:f.H3,h4:f.H4,h5:f.H5,h6:f.H6,hr:A.Z,blockquote:y.Z,ul:v.Z,ol:E.Z,pre:Z.Z,code:k.Z}},r))),(0,x.tZ)(R,null,(0,x.tZ)(S,null,(0,x.tZ)(m.Z,null)))))},N=(0,o.Z)("div",{target:"e1ojob7j7"})({name:"11t2x7x",styles:"display:flex;height:var(--header-height);z-index:5;padding:0.6rem 2rem 0.6rem 0.6rem;position:fixed;width:100%;background:var(--background-color);border-bottom:1px solid var(--border-color)"}),z=(0,o.Z)("div",{target:"e1ojob7j6"})({name:"majwgz",styles:"position:relative;display:flex;min-height:calc(100vh - var(--header-height));overflow-x:hidden"}),C=(0,o.Z)("aside",{target:"e1ojob7j5"})("margin-left:",(e=>e.isNavOpened?"0":"calc(-1 * var(--sidebar-width))"),";flex:0 0 var(--sidebar-width);font-size:0.875rem;overflow-x:hidden;overflow-y:auto;transition:margin 0.25s var(--ease-in-out-quad);@media (min-width: ",h.Z.IPAD_PRO,"px){margin-left:0;}"),M=(0,o.Z)("nav",{target:"e1ojob7j4"})({name:"l4vzaw",styles:"overflow-y:auto;height:100%;padding:var(--body-padding-top) 0 3rem 0;position:fixed;width:var(--sidebar-width);&:-webkit-scrollbar{display:none;}"}),O=(0,o.Z)("main",{target:"e1ojob7j3"})("padding:1rem;width:100%;@media (min-width: ",h.Z.IPAD_AIR,"px){width:",(e=>e.isWide?"90%":"65%"),";}"),P=(0,o.Z)("main",{target:"e1ojob7j2"})("width:calc(100% - 2 * var(--sidebar-width));padding-top:var(--body-padding-top);flex-grow:1;min-width:20rem;display:flex;justify-content:center;opacity:",(e=>e.isNavOpened?.3:1),";@media (min-width: ",h.Z.IPAD_PRO,"px){opacity:1;}"),R=(0,o.Z)("aside",{target:"e1ojob7j1"})("font-size:0.75rem;font-weight:bold;overflow-x:hidden;overflow-y:auto;padding-top:var(--body-padding-top);width:0;transition:width 0.25s var(--ease-in-out-quad);@media (min-width: ",h.Z.HD,"px){width:var(--sidebar-width);}"),S=(0,o.Z)(M,{target:"e1ojob7j0"})({name:"b40oxt",styles:"padding:0 1rem 0 1rem"});function T(e){return l.createElement(j,e,l.createElement(s,e))}}}]);
//# sourceMappingURL=component---src-components-templates-main-template-tsx-content-file-path-contents-nlp-pretraining-mdx-efd535ce8b3649ec8443.js.map