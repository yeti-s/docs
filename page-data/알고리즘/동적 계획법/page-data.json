{"componentChunkName":"component---src-components-templates-main-template-tsx-content-file-path-contents-cs-algorithm-dp-dp-mdx","path":"/알고리즘/동적 계획법","result":{"data":{"mdx":{"id":"53be9062-2e9c-5edc-b596-19c2fd0cbcb7","body":"\r\n`동적 계획법 DP(Dynamic Programming)`은 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 일종의 문제 해결법으로 볼 수 있습니다.\r\n즉 작은 문제로 쪼개서 답을 저장해두고 이를 재활용하는 기억하며 풀기 방법이라 할 수 있죠.\r\n일반적인 재귀를 사용하면 동일한 문제가 반복 계산되는데, 이를 효율적으로 활용할 수 있어요.\r\n\r\nDP가 적용되기 위해서 2가지 조건을 만족해야 합니다.\r\n* Overlapping Subproblems  \r\nDP는 기본적으로 큰 문제를 작은 문제들로 나누고 값을 재활용하여 문제를 해결합니다.\r\n따라서 동일한 작은 문제들이 반복하여 나타나야 이를 활용할 수 있는 것이죠.\r\n\r\n* Optimal Substructure  \r\n작은 문제의 최적 결과 값을 활용하여 전체 문제의 최적 결과를 나타낼 수 있어야 합니다.\r\n\r\n\r\n# Knapsack\r\n\r\n![](knapsack_problem.png)\r\n\r\n위 그림과 같이 최대 적재량이 존재하는 배낭과 각각 무게와 가치를 가지는 아이템이 존재합니다.\r\n이때 배낭에 들어가는 아이템 가치의 합이 가장 높을 때 값은?\r\n\r\n이는 배낭의 최대 용량이 $w$일 때, $i$번째 아이템까지 넣었을 때 최대 가치를 계산하는 방법으로 구현할 수 있다.\r\n위 문제에서 표를 만들어 본다면 아래와 같이 표현할 수 있다.\r\n\r\n![](knapsack_sol_01.png)\r\n\r\n첫 번째 아이템을 넣기 위해 $3kg$ 이상의 공간이 필요합니다.\r\n따라서 $w$가 3이하에서 0의 가치를, $w$가 3이상에서 4의 가치를 가지게 되죠.\r\n$$\r\n[0:2, 1] = 0, [3:6, 1] = 4\r\n$$\r\n\r\n![](knapsack_sol_02.png)\r\n\r\n두 번째 아이템을 넣는 경우를 생각해봅시다.\r\n$w$가 1, 2일 때 아무 아이템도 들어가지 않았던 첫 번째 순서에 비해 무게가 1인 두 번째 아이템에 경우에는 가방에 들어갈 수 있겠죠.\r\n$$\r\n[1:2, 2] = 1 \\tag{1}\r\n$$\r\n\r\n그러나 $w$가 3일 때 첫 번째 아이템이 들어가있는 경우의 가치가 첫 번째 아이템을 빼고 두 번째 아이템을 넣는 경우보다 더 높습니다.\r\n따라서 이 경우에는 두 번째 아이템을 넣지 않는 것이죠.\r\n$$\r\n[3, 2] = 4 \\tag{2}\r\n$$\r\n\r\n$w$가 4이상인 경우, 기존에 들어간 첫 번째 아이템에 추가로 두 번째 아이템을 넣을 수 있습니다.\r\n$$\r\n[4:6, 2] = 6 \\tag{3}\r\n$$\r\n\r\n위 세 가지 경우를 조금 일반화 해볼게요.\r\n위 식 모두는 동일 용량의 직전 아이템까지 넣었을 때 가치와, 새로 들어오는 아이템의 용량만큼 비운 후 새로운 아이템의 가치를 더한 값을 비교해서\r\n더 큰 값을 취한다는 전략을 사용할 수 있을 것입니다.\r\n$$\r\n[1:2, 2] = \\max ([1:2, 1], [1-1:2-1, 2] + 2) \\tag{1'}\r\n$$\r\n$$\r\n[3, 2] = \\max ([3, 1], [3-1, 2] + 2) \\tag{2'}\r\n$$\r\n$$\r\n[4:6, 2] = \\max ([4:6, 1], [4-1:6-1, 2] + 2) \\tag{3'}\r\n$$\r\n\r\n이를 모든 항에 적용할 수 있도록 일반화한다면\r\n$$\r\n[w, i] = \\max ([w, i-1], [w-{item \\ weight}, i-1] + {item \\ value})\r\n$$\r\n\r\n이 식을 이용하여 모든 표를 작성하면 아래와 같은 순서로 완성시킬 수 있겠습니다.\r\n\r\n![](knapsack_sol_03.png)\r\n![](knapsack_sol_04.png)\r\n![](knapsack_sol_05.png)\r\n![](knapsack_sol_06.png)\r\n\r\n이를 코드로 구현해볼게요.\r\n\r\n```python\r\nbag = 6\r\nitems = [[4, 3], [2, 1], [5, 6], [6, 5], [1, 2], [3, 3]]\r\n\r\nvalues = [0]\r\nweights = [0]\r\nfor item in items:\r\n    values.append(item[0])\r\n    weights.append(item[1])\r\n\r\nimport numpy as np\r\nnum_items = len(values)\r\nval_map = np.zeros((bag + 1, num_items))\r\nval_map\r\n```\r\n```\r\narray([[0., 0., 0., 0., 0., 0., 0.],\r\n       [0., 0., 0., 0., 0., 0., 0.],\r\n       [0., 0., 0., 0., 0., 0., 0.],\r\n       [0., 0., 0., 0., 0., 0., 0.],\r\n       [0., 0., 0., 0., 0., 0., 0.],\r\n       [0., 0., 0., 0., 0., 0., 0.],\r\n       [0., 0., 0., 0., 0., 0., 0.]])\r\n```\r\n\r\n```python\r\nfor i in range(1, num_items):\r\n    value = values[i]\r\n    weight = weights[i]\r\n    \r\n    for w in range(1, bag+1):\r\n        if w < weight:\r\n            val_map[w, i] = val_map[w, i-1]\r\n            continue\r\n        \r\n        if w == 0:\r\n            val_map[w, i] = max(val_map[w, i-1], value)\r\n        else:\r\n            val_map[w, i] = max(val_map[w, i-1], value + val_map[w - weight, i-1])\r\n            \r\nval_map\r\n```\r\n```\r\narray([[0., 0., 0., 0., 0., 0., 0.],\r\n       [0., 0., 2., 2., 2., 2., 2.],\r\n       [0., 0., 2., 2., 2., 2., 2.],\r\n       [0., 4., 4., 4., 4., 4., 4.],\r\n       [0., 4., 6., 6., 6., 6., 6.],\r\n       [0., 4., 6., 6., 6., 6., 6.],\r\n       [0., 4., 6., 6., 8., 8., 8.]])\r\n```\r\n\r\n# 동전 교환\r\n\r\n1, 3, 4원짜리 동전이 있을 때, $x$원을 최소한의 동전으로 교환하는 문제\r\n\r\n이는 Greedy Algorithm으로 해결한다면 4, 1, 1로 3개의 동전이 필요합니다.\r\n하지만 3, 3으로 2개의 동전만으로도 교환할 수 있죠.\r\n이를 DP로 구현해봅시다.\r\n\r\n$f(x)$는 $x$를 교환 가능한 최소한의 동전 수 라고 할 때, 먼저 1, 2, 3, 4에 대해 최적의 방법을 구합니다.\r\n```\r\nf(1) = 1\r\nf(2) = 2\r\nf(3) = 1\r\nf(4) = 1\r\n```\r\n\r\n이후 $x$를 1씩 원하는 금액에 이를 때까지 증가시킵니다.\r\n이때 이전에 계산한 결과를 이용하는 방식이죠.\r\n```\r\nf(5) = min(f(5-1)+1, f(5-2)+1, f(5-4)+1)\r\nf(6) = min(f(6-1)+1, f(6-2)+1, f(6-4)+2)\r\n```\r\n\r\n이렇게 DP를 이용하여 동전 교환 문제를 해결할 수 있습니다.\r\n\r\n```python\r\ncoins = {1, 5, 10, 20}\r\ntarget = 72\r\n\r\nresults = [0 for _ in range(target)]\r\nunits = {}\r\nfor coin in coins:\r\n    results[coin-1] = 1\r\n    units[coin] = True\r\n\r\nfor i in range(1, target):\r\n    if results[i] > 0:\r\n        continue\r\n\r\n    min_result = 1e8\r\n    best = 0\r\n    for coin in coins:\r\n        if i+1-coin < 0:\r\n            continue\r\n        result = results[i-coin]\r\n        if min_result > result:\r\n            min_result = result\r\n            best = coin\r\n            \r\n    results[i] = min_result + 1\r\n\r\nresults[-1] # 6\r\n```\r\n\r\n","tableOfContents":{"items":[{"url":"#knapsack","title":"Knapsack"},{"url":"#동전-교환","title":"동전 교환"}]},"frontmatter":{"description":"동적 계획법의 3가지 유형에 대해 공부한다.","title":"동적 계획법","date":"2024년 01월 17일"}}},"pageContext":{"id":"53be9062-2e9c-5edc-b596-19c2fd0cbcb7","frontmatter":{"title":"동적 계획법","description":"동적 계획법의 3가지 유형에 대해 공부한다.","date":"2024년 01월 17일","subject":"알고리즘","visible":true,"order":2}}},"staticQueryHashes":["1569657708","2317542362"],"slicesMap":{}}