{"componentChunkName":"component---src-components-templates-main-template-tsx-content-file-path-contents-coding-test-03-132266-mdx","path":"/5bc79594-fa85-528a-a2a0-cc0c0dc2e44e","result":{"data":{"mdx":{"id":"5bc79594-fa85-528a-a2a0-cc0c0dc2e44e","body":"\r\nimport TestInfo from './components/TestInfo'\r\n\r\n<TestInfo url='https://school.programmers.co.kr/learn/courses/30/lessons/132266' level={3} solved={false}></TestInfo>\r\n\r\n# 문제 분석\r\n\r\n각 포인트에서 특정 포인트로 가야 합니다.\r\n모든 포인트와 포인트 사이 거리는 1이라고 합니다.\r\n그런데 어떤 포인트에서 포인트까지 가는 길이 부서져서 갈 수 없는 길도 있다고 하는군요.\r\n이 때 출발지에서 도착지까지 가장 빠르게 도착하는 경로를 계산하는 문제에요.\r\n모든 경로가 차단되어 도착지까지 절대 갈 수 없는 경우가 생긴다면 -1을 반환합니다.\r\n\r\n간단하게 생각하면 최단 경로를 찾는 다익스트라 알고리즘으로 풀 수 있을 것 같아요.\r\n\r\n# 풀이\r\n\r\n먼저 경로에 대한 연결을 나타내는 행렬을 만들어보죠.\r\n```python\r\nimport numpy as np\r\nmatrix = np.ones((n, n)) * (n+1)\r\n\r\nfor road in roads:\r\n    node1 = road[0]-1\r\n    node2 = road[1]-1\r\n    matrix[node1, node2] = 1\r\n    matrix[node2, node1] = 1\r\n\r\nfor i in range(n):\r\n    matrix[i, i] = 0\r\n```\r\n\r\n자기 자신에 대한 경로는 0으로 만들어 주고 연결이 되지 않은 지역은 포인트의 수 보다 큰 n+1로 정해주었어요.\r\n이제 다익스트라 알고리즘을 사용하여 출발 지점에서 각 포인트까지 최단 경로를 찾아봅시다.\r\n\r\n```python\r\ndef get_min_route(s, e):\r\n    for i in range(n):\r\n        argsort = matrix[s].argsort()\r\n        min_idx = argsort[i]\r\n        if s == min_idx:\r\n            continue\r\n            \r\n        min_val = matrix[s, min_idx]\r\n        for j in range(n):\r\n            s_to_j = min_val + matrix[min_idx, j]\r\n            if matrix[s, j] > s_to_j:\r\n                matrix[s, j] = s_to_j\r\n                \r\n    result = matrix[s, e]\r\n    return -1 if result > n else result\r\n```\r\n\r\n각 시작 포인트에서 다른 포인트까지 연결된 거리가 짧은 순으로 정렬한 후 경유하여 도착하는 값까지 모두 계산하였습니다.\r\n이때 도착 포인트까지 연결이 없어 n+1 값을 그대로 가지는 경로에 대해 -1을 반환하도록 만들어 주었어요.\r\n이 코드를 제출하여 결과를 확인해 봅시다.\r\n\r\n```python\r\nimport numpy as np\r\n\r\ndef solution(n, roads, sources, destination):\r\n    answer = []\r\n    matrix = np.ones((n, n)) * (n+1)\r\n    \r\n    for road in roads:\r\n        node1 = road[0]-1\r\n        node2 = road[1]-1\r\n        matrix[node1, node2] = 1\r\n        matrix[node2, node1] = 1\r\n    \r\n    for i in range(n):\r\n        matrix[i, i] = 0\r\n    \r\n    def get_min_route(s, e):\r\n        for i in range(n):\r\n            argsort = matrix[s].argsort()\r\n            min_idx = argsort[i]\r\n            if s == min_idx:\r\n                continue\r\n                \r\n            min_val = matrix[s, min_idx]\r\n            for j in range(n):\r\n                s_to_j = min_val + matrix[min_idx, j]\r\n                if matrix[s, j] > s_to_j:\r\n                    matrix[s, j] = s_to_j\r\n                    \r\n        result = matrix[s, e]\r\n        return -1 if result > n else result\r\n                \r\n    for source in sources:\r\n        result = get_min_route(source-1, destination-1)\r\n        answer.append(result)\r\n        \r\n    return answer\r\n```\r\n\r\n테스트 1~5까지 통과라고 뜨지만 6~16까지 시간초과, 런타임 에러가 발생하네요.\r\n알고리즘을 조금 더 효과적으로 수정할 필요가 있습니다.\r\n\r\n우리는 여러 시작 포인트에서 도착 포인트까지 경로를 조사하는 형태로 알고리즘을 구성하였지만,\r\n이는 각 시작 포인트마다 모든 포인트까지 경로를 조사하는 비효율적인 방법었네요.\r\n생각해보면 그냥 도착포인트에 대한 모든 포인트까지 경로를 한번만 조사하면 되는 간단한 문제였어요.\r\n\r\n위 방법으로 시간초과는 해결할 수 있겠지만 정확하게 어떤 부분에러 런타임 에러가 발생하는지 확인을 할 필요가 있겟어요.\r\n단순히 numpy 배열 만드는 것만으로도 런타임 오류가 발생하네요.\r\n메모리의 크기가 정해져서 그런 걸까요?\r\n\r\n```python\r\nmatrix = [[n+1]*n for _ in range(n)]\r\n```\r\n단순히 위 배열을 선언하는 것만 해도 11~16번이 시간 초과로 발생합니다.\r\n다익스트라 알고리즘은 안되는 듯,,\r\n\r\n# 힌트\r\nBFS로 풀면 된다는 힌트를 받았어요.\r\n사실상 그냥 정답을 받은거나 다름 없는,,\r\n이런 알고리즘에 제가 취약하다는 것을 또 깨닫는 순간입니다.\r\nBFS에 대한 정리는 [여기](/algorithm/bfs)에 해두었어요\r\n\r\n이 문제는 제한사항을 보면 $3 \\leq n \\leq 100000$으로 포인트의 수가 굉장히 많습니다.\r\n이를 $n \\times n$ 배열로 만든다면 메모리가 부족할 수 밖에 없었을 거에요.\r\n\r\n또한 각 포인트와 포인트의 거리는 1로 동일하다는 것을 주목해야 했어요.\r\n가중치가 없는 형태이기 때문에 다익스트라 알고리즘을 굳이 사용하지 않아도 되었지요.\r\n\r\n```python\r\ngraph = [[] for _ in range(n+1)]\r\nfor road in roads:\r\n    node1 = road[0]\r\n    node2 = road[1]\r\n    graph[node1].append(node2)\r\n    graph[node2].append(node1)\r\n```\r\n먼저 각 노드들과 연결된 노드들의 관계를 그래프로 설정하도록 합니다.\r\n\r\n```python\r\nvisited = {destination: 0}\r\nqueue = deque([(destination, 0)])\r\nwhile(len(queue) > 0):\r\n    item = queue.popleft()\r\n    node = item[0]\r\n    wide = item[1]\r\n    for tar in graph[node]:\r\n        if tar not in visited:\r\n            queue.append((tar, wide+1))\r\n            visited[tar] = wide+1\r\n```\r\n이제 queue와 그래프를 이용하여 연결된 노드들에 대한 방문을 우선으로 하는 BFS 알고리즘을 만들었어요.\r\n이를 실행해보니 깔끔하게 모든 테스트가 완료되었어요.\r\n\r\n전체 코드\r\n```python\r\nfrom collections import deque\r\n\r\ndef solution(n, roads, sources, destination):\r\n    answer = []\r\n    \r\n    graph = [[] for _ in range(n+1)]\r\n    for road in roads:\r\n        node1 = road[0]\r\n        node2 = road[1]\r\n        graph[node1].append(node2)\r\n        graph[node2].append(node1)\r\n\r\n    visited = {destination: 0}\r\n    queue = deque([(destination, 0)])\r\n    while(len(queue) > 0):\r\n        item = queue.popleft()\r\n        node = item[0]\r\n        wide = item[1]\r\n        for tar in graph[node]:\r\n            if tar not in visited:\r\n                queue.append((tar, wide+1))\r\n                visited[tar] = wide+1\r\n        \r\n    for source in sources:\r\n        if source in visited:\r\n            answer.append(visited[source])\r\n        else:\r\n            answer.append(-1)\r\n    \r\n    return answer\r\n```\r\n\r\n","tableOfContents":{"items":[{"url":"#문제-분석","title":"문제 분석"},{"url":"#풀이","title":"풀이"},{"url":"#힌트","title":"힌트"}]},"frontmatter":{"description":"연습문제","title":"부대 복귀"}},"file":{"modifiedTime":"2023-12-15T09:20:59.971Z"}},"pageContext":{"id":"5bc79594-fa85-528a-a2a0-cc0c0dc2e44e","relativePath":"coding_test/03_132266.mdx","frontmatter":{"title":"부대 복귀","description":"연습문제","order":3}}},"staticQueryHashes":["123912876","2317542362"],"slicesMap":{}}