{"componentChunkName":"component---src-components-templates-main-template-tsx-content-file-path-contents-quantization-smooth-quant-mdx","path":"/3202577a-3666-51a1-955d-6abc53c6c881","result":{"data":{"mdx":{"id":"3202577a-3666-51a1-955d-6abc53c6c881","body":"\r\nimport ColorText from '@contents/components/ColorText';\r\nimport Comment from '@contents/components/Comment';\r\n\r\n[SmoothQuant: Accurate and Efficient Post-Training Quantization for Large Language Models](https://arxiv.org/abs/2211.10438) 논문을 바탕으로 작성하였습니다.\r\n\r\n# Introduction\r\nLarge-scale language model(LLM)은 다양한 분야에서 뛰어난 성과를 내고 있다.\r\n하지만 큰 모델 사이즈로 인해 LLM 서비스를 제공하는 것에는 큰 비용이 든다.\r\n예를 들어 GPT-3 모델은 175B 파라미터가 존재하고 FP16 형태로 실행하기 위해 350GB의 메모리가 필요하다.\r\n따라서 weight와 activation을 적은 비트로 quantization하는 방법으로 GPU 요구량을 줄이고 계산을 가속화할 수 있다.\r\n\r\n그러나 CNN모델 또는 BERT와 같은 작은 transformer 모델과 달리 LLM의 activation을 quantization하는 것은 쉽지 않다.\r\n6.7B 이상의 LLM 모델은 activation에 큰 규모의 시스템적 outliers들이 등장해서 quantization error를 증가시키고 정확도를 감소시킨다.\r\n[**ZeroQuant**](https://arxiv.org/pdf/2206.01861.pdf)는 GPT-3-350M, GPT-J-6B 모델에서 좋은 성능을 냈지만 OPT-175B에서는 정확도를 유지하지 못했다.\r\n[**LLM.int8**](https://arxiv.org/pdf/2208.07339.pdf)는 하드웨어 가속기에 효과적으로 decomposition을 구현하기 어렵다.\r\n그러므로 효과적, 하드웨어 친화적, 그리고 훈련이 필요 없는 quantization 방법이 필요하다.\r\n\r\n<Comment>\r\nBERT와 같은 작은 transformer는 quantization이 쉬운 것일까?\r\nZeroQuant가 GPT와 OPT에서 효율이 다른 원인은 무엇인가?\r\n</Comment>\r\n\r\nSmoothQuant는 서로 다른 토큰에서 채널에 대한 비슷한 분포로 outlier가 존재한다는 관찰을 기반으로 한다.\r\nSmoothQuant는 quantization의 어려움을 activation에서 weight로 offline하게 이동시켰다.\r\n\r\n<Comment>\r\nactivation의 quantization이 더 어렵다는 분석 아래에 적혀 있지만 인용한 LLM.int8 논문 추가로 살펴보자.\r\n찾아보니 그냥 분포를 관찰한 것이었다. 이유는 따로 없음!\r\n</Comment>\r\n\r\n# Review of Quantization Difficulty\r\nLLM의 quantization을 어렵게 하는 activation outlier의 몇몇 패턴을 관측하였다.  \r\n![Figure 4](assets/smooth_quant/00.png)\r\n\r\n1. activation이 weight보다 quantization하기 어렵다.  \r\nweight의 분포는 꽤 평평하여 INT8 심지어 INT4로 quantize 하여도 정확도가 감소하지 않았다.\r\n2. outlier가 activation quantization을 어렵게 한다.\r\nactivation의 outlier는 다른 값보다 ~100배 더 크게 관측되었다.\r\n이러한 경우에 per-tensor quantization을 진행한다면 outlier에 의해 큰 quantization error를 만든다.\r\n3. outlier는 고정된 channel에 나타난다.\r\n만약 한 채널에 outlier가 있었다면, 해당 채널은 모든 토큰에서 outlier를 가진다.\r\n그래서 per-channel quantization을 per-tensor quantization보다 더 작은 quantization error를 가지게 된다.\r\n하지만 per-channel quantization은 ___GEMM___ 커널에 적합하지 않다.  \r\n![Table 1](assets/smooth_quant/01.png)\r\n\r\n<Comment>\r\nGEMM 커널이 뭔지 찾아보자.\r\n</Comment>\r\n\r\n# SmoothQuant\r\nper-channel quantization 대신 smoothing factor $s$를 이용하여 linear layer의 동일한 수학적 결과를 만든다.\r\nquantization error를 줄이기 위해 모든 channel을 동일한 규모로 만든다.\r\n$$\r\ns_j=max(\\left| X_j \\right|), j=1,2,\\cdots,C_j\r\n$$\r\nactivation에 $s_j$를 나누어 모든 channel이 동일한 규모로 만들어 quantization error를 줄인다.\r\nactivation의 범위는 동적이기 때문에 몇몇의 calibration sample을 통해 scale을 추정해야 한다.\r\n$$\r\nY=(Xdiag(s)^{-1})\\cdot(diag(s)W)=\\hat{X}\\hat{Y}\r\n$$\r\n동일한 수학적 계산을 위해 weight에 앞서 구한 $s_j$를 곱해준다.\r\n하지만 이러한 방법은 quantization error를 activation에서 weight로 이동시키는 역할을 할 뿐이다.\r\n그래서 quantization difficulty를 weight와 activation이 적절하게 부담할 수 있도록 할 필요가 있다.\r\n\r\nquantization difficulty를 weight와 activation이 부담하는 정도를 결정하기 위해서 hyper-parameter $\\alpha$를 추가한다\r\n$$\r\ns_j=max(\\left| X_j \\right|)^{\\alpha}/max(\\left| W_j \\right|)^{1-\\alpha}\r\n$$\r\n![Figure 5](assets/smooth_quant/02.png)  \r\n$\\alpha$를 큰 값으로 설정하여 quantization difficulty를 weight에 더 부담하는 등 hyper-parameter의 조절을 통해 quantization difficulty를 조절할 수 있다.\r\n대부분의 모델에서 $\\alpha=0.5$에서 균형을 갖춘 quantization difficulty를 확인할 수 있었다.\r\n\r\n기본적으로 self-attention과 feed-forward layer에 대해 smoothing을 적용하였다.\r\nReLU, Softmax, 그리고 Layer-Norm과 같은 연산은 FP16으로 유지하였고,\r\n무거운 연산을 하는 linear layer와 BMM(Batched Matrix Multiplication)에 대해 W8A8(weight 8 actication 8) quantization을 적용하였다.\r\n![Figure 6](assets/smooth_quant/03.png)\r\n\r\n\r\n<Comment>\r\n그럼 caplibration sample data가 많을 수록 더 정확한 scale값을 추정할 수 있다고 말할 수 있을까?\r\n구현을 sample data에 대한 activation의 max값을 이용하여 scaling을 적용하는데, 몇몇 특수 케이스가 해당 max값을 너무 높여서 꼭 데이터가 많다고 좋아지는 것은 아닌 것 같았다.\r\n</Comment>\r\n\r\n# Implement\r\n\r\n위 논문을 바탕으로 구현을 시작해 봅시다.\r\n\r\n## FakeQuant\r\n\r\npytorch는 실제로 int8 연산을 지원하지 않기 때문에 float32 연산이지만 quantization을 하는 것처럼 시뮬레이션하는 fake quantization을 만들어 볼게요.\r\nquantization을 어떤 범위로 하느냐에 따라 per-tensor, per-token, per-channel 등 여러 종류가 있지만 per-tensor로 구현을 해봅시다.\r\n\r\n```python\r\n@torch.no_grad()\r\ndef quantize_symmetric_per_tensor(tensor:torch.Tensor, n_bits:int):\r\n    t_max = torch.max(torch.abs(tensor))\r\n    q_max = 2**(n_bits - 1) - 1\r\n    scale = t_max.clamp(EPS).div(q_max)\r\n    q_tensor = tensor.div(scale).round()\r\n    return q_tensor, scale, torch.tensor(0)\r\n```\r\n\r\nquantization시 텐서가 가지고 있는 규모를 n bit에 나눠서 분할하기 때문에 크기를 조절해주는 scale을 구합니다.\r\n이를 이용해서 tensor를 quantization 해보았어요.  \r\n그럼 matmul 연산을 이용하여 테스트를 해 볼까요?\r\n\r\n```python\r\ndef matmul_with_quantize(t1, t2, quantize):\r\n    q1, s1, z1 = quantize(t1, 8)\r\n    q2, s2, z2 = quantize(t2, 8)\r\n    return torch.matmul(q1+z1, (q2+z2).T) * s1 * s2\r\n\r\ntorch.manual_seed(42)\r\nt1 = torch.rand(128, 768) * 2 - 1\r\nt2 = torch.rand(128, 768) * 2 - 1\r\nmatmul_result = torch.matmul(t1, t2.T)\r\nq_matmul_result = matmul_with_quantize(t1, t2, quantize_symmetric_per_tensor)\r\nprint('MSE loss', F.mse_loss(matmul_result, q_matmul_result))\r\n```\r\n\r\n```\r\nMSE loss tensor(0.0027)\r\n```\r\n\r\nquantized된 두 tensor를 이용하여 연산을 진행한 후 원래 크기로 돌려주기 위해 scale값을 곱해줍니다.\r\n평균 제곱 오차를 구하면 약 0.0027 정도가 되네요.\r\n\r\n위 방법은 0을 기준으로 양수와 음수를 같은 규모로 양자화를 적용하는 symmetric quantization 이에요.\r\n만약에 tensor가 0을 기준으로 양수 혹은 음수에 조금 더 많이 분포하는 경향이 있으면 이 방법은 비효율적이죠.\r\n아래 예시를 보겠습니다.\r\n\r\n```python\r\nt1 = t1 + 10\r\nt2 = t2 - 10\r\nq_matmul_result = matmul_with_quantize(t1, t2, quantize_symmetric_per_tensor)\r\nprint('MSE loss', F.mse_loss(matmul_result, q_matmul_result))\r\n```\r\n\r\n```\r\nMSE loss tensor(84.2358)\r\n```\r\n\r\n극단적으로 t1은 전부 양수값을 가지도록, t2는 전부 음수값을 가지도록 설정해보았어요.\r\n그 후 symmetric quantization을 진행하였는데 기존 값과 오차가 훨씬 큰 것을 볼 수 있어요.\r\n\r\n이런 친구들을 위해 0 기준 양쪽에 bit를 동등하게 할당하지 않고 tensor의 최대 최소값을 구한 후 중앙값을 0으로 만들어주는 전략을 취한다면?\r\n사실 앞서 quantize 함수에서 quantized된 tensor와 scale 값, 그리고 또 하나의 값을 반환하였어요.\r\n이것이 중앙값을 0으로 만들어주는 일종의 offset 개념인 zero point 입니다.\r\n우리는 zero point를 이용하여 asymmetric quantizatio을 만들어 봅시다.\r\n\r\n```python\r\n@torch.no_grad()\r\ndef quantize_asymmetric_per_tensor(tensor:torch.Tensor, n_bits:int):\r\n    t_max = torch.max(tensor)\r\n    t_min = torch.min(tensor)\r\n    scale = (t_max - t_min) / (2**n_bits - 1)\r\n    zero_point = torch.round((t_max + t_min)/ 2 / scale)\r\n    q_tensor = torch.round(tensor / scale) - zero_point\r\n    return q_tensor, scale, zero_point\r\n```\r\n\r\ntensor의 최대 최소값의 범위만큼 bit를 할당하도록 scale값과 할당된 bit의 중앙값을 설정하는 zero point를 구하였습니다.\r\n이를 사용하여 아까 편향된 텐서를 계산해서 기존 결과와 얼마나 차이가 나는지 테스트 해 보겠습니다.\r\n\r\n```python\r\nq_matmul_result = matmul_with_quantize(t1, t2, quantize_asymmetric_per_tensor)\r\nprint('MSE loss', F.mse_loss(matmul_result, q_matmul_result))\r\n```\r\n\r\n```\r\nMSE loss tensor(0.6758)\r\n```\r\n\r\nsymmetric quantization 방법과 비교하면 loss가 크게 감소한 것을 볼 수 있네요.\r\n이렇게 보면 asymmetric quantization이 무조건 좋은 방법처럼 보이지만 symmetric에 비해 추가적인 연산을 해야 하는 부분이 있죠.\r\n그래서 두 가지 방법을 적절하게 사용하는 능력이 중요할 것 같네요.\r\n\r\n<Comment>\r\n구현을 진행하며 알게 된 사실인데 float16 연산에 대해 clamp와 round 함수에 오류가 발생햇다.\r\n알고보니 float16에 대한 해당 함수들은 cpu에서 불가능하고 cuda에서만 가능하였다. 허허 참..\r\n</Comment>\r\n\r\n\r\n위에서 만든 함수를 이용하여 linear 레이어의 weight와 bias, 그리고 input에 대해 quantization을 진행하는 새로운 레이어를 만들어 볼게요.\r\n먼저 기존 레이어의 weight는 이미 알고 있는 값이기에 이를 quantize한 값과 $s_w$, $z_w$를 만들거예요.\r\nLLM과 같은 모델에서 미리 어떤 scale 값으로 quantization을 진행할지 정해두는 static quantization 보다, \r\ninput에 대해 동적으로 quantization을 진행하는 dynamic quantization이 더 효율이 좋다고 합니다.\r\n우리는 LLM을 타겟으로 하기 때문에 input을 동적으로 quantization을 진행하고 $s_x$와 미리 계산해 둔 $s_w$를 이용하여 bias 역시 quantization을 진행하도록 하죠.\r\n즉, weight만이 offline으로 계산되었고, 나머지는 동적으로 계산되는 형태를 가지게 될 것입니다.\r\n\r\n```python\r\nclass FakeQuantLinear(nn.Module):\r\n    def __init__(self, weight:torch.Tensor, bias:torch.Tensor, n_bits:int, quantize=quantize_symmetric_per_tensor) -> None:\r\n        super().__init__()\r\n\r\n        self.quantize = partial(quantize, n_bits=n_bits)\r\n        q_w, s_w, z_w = self.quantize(weight)\r\n        self.register_buffer('weight', q_w.squeeze(0))\r\n        self.register_buffer('s_w', s_w)\r\n        self.register_buffer('z_w', z_w)\r\n        self.register_buffer(\"bias\", bias)\r\n        \r\n    def forward(self, x):\r\n        q_x, s_x, z_x = self.quantize(x)\r\n        scale = s_x * self.s_w\r\n        bias = self.bias if self.bias is None else self.bias.div(scale).round()\r\n        out = F.linear(q_x.sub(z_x), self.weight.sub(self.z_w), bias)\r\n        return out.mul_(scale)\r\n```\r\n\r\n\r\n이를 적용해서 기존의 linear 레이어와 얼마나 차이가 발생하는지 테스트를 진행해볼게요.\r\n\r\n```python\r\nlinear = nn.Linear(t.size(1), 512)\r\nresult = linear(t)\r\nquant_linear = FakeQuantLinear(linear.weight.detach(), linear.bias.detach(), 8)\r\nprint('[quantized linear] MSE loss', F.mse_loss(result, quant_linear(t)).item())\r\n```\r\n```\r\nMSE loss 3.4490449252189137e-06\r\n```\r\n\r\n## SmoothQuant\r\n\r\n위에서 실제 quantization과 비슷하도록 시뮬레이션 할 수 있는 fake quantization을 구현하였어요.\r\n이제 이를 활용하여서 기존의 linear 레이어의 outlier를 scaling하는 smooth quantization을 구현하도록 하겠습니다.\r\n\r\nsmooth quant를 적용하기 위해서 해당 레이어의 activation의 채널별 최대값, weight의 채널별 최대값이 필요합니다.\r\nweight는 학습을 진행하고 나면 고정되어 최대값을 얻을 수 있지만, activation은 실시간으로 다른 값이 들어오기 때문에 미리 얻을 수 없죠.\r\n그래서 sample data를 활용하여 해당 레이어의 activation 값을 어느정도 미리 조사하고 이를 활용하는 방식을 사용합니다.\r\n일단은 activation의 scale값을 가지고 있다고 생각하고 구현을 합시다.\r\n\r\n먼저 activation의 channel과 연산을 담당하는 weight의 out channel에 대해 최대값들을 구해줍니다.\r\n이를 activation scale값에 각각 일정 비율로 나눠어 smooth scale을 구할거예요.\r\n여기서 일정 비율이란 $\\alpha$값을 의미하는데 activation과 weight의 scaling중 어느 부분에 더 중점을 둘지 정하는 하이퍼 파라미터에요.\r\n대부분의 경우 0.5로 두어도 잘 작동한다고 합니다.\r\n위에서 구한 smooth scale을 이용하여 weight를 scale up 해주고 들어오는 input을 scale down을 해줄거에요.\r\n그리고 그 값들을 이용하여 quantization을 진행하는 것입니다.\r\n\r\n```python\r\nEPS = 1e-8\r\nclass SmoothQuantLinear(nn.Module):\r\n    def __init__(self, weight:torch.Tensor, bias:torch.Tensor, act_scale:torch.Tensor, n_bits:int, alpha:float = 0.5):\r\n        super(SmoothQuantLinear, self).__init__()\r\n        \r\n        w_abs_max = weight.abs().max(dim=0)[0].clamp(min=EPS)\r\n        scale = act_scale.pow(alpha).div(w_abs_max.pow(1 - alpha)).clamp(min=EPS)\r\n        self.register_buffer(\"scale\", scale) # smoothing scale\r\n        self.fake_quant_linear = FakeQuantLinear(weight * scale.view(1, -1), bias, n_bits)\r\n\r\n    def smooth(self, x):\r\n        return x / self.scale\r\n    \r\n    def forward(self, x):\r\n        smooth_x = self.smooth(x)\r\n        output = self.fake_quant_linear(smooth_x)\r\n        return output\r\n```\r\n\r\n이제 기존의 linear 레이어와 fake quant linear 레이어, smooth quant linear 레이어의 오류 차이를 비교해볼게요.\r\n일단 우리가 smooth quant를 적용하는 목적인 특정 채널에 대해서 outlier가 존재하는 텐서를 만들어줍니다.\r\n\r\n```python\r\ntorch.manual_seed(42)\r\nt = torch.rand((1, 128, 768))\r\nt[:,:,torch.randint(0, 767, (5,))] = torch.rand((1, 128, 5)) * 10 + 50\r\n```\r\n\r\n![](assets/smooth_quant/04.png)\r\n\r\n위에서 생성한 텐서의 모습을 그래프로 표현한거예요.\r\n다섯개의 채널에 대해서만 높은 값을 가지는 것을 볼 수 있죠.\r\n이를 이용하여 간단한 linear 레이어와 이를 두 가지 방식으로 quantization한 레이어의 오차를 비교합시다.\r\n\r\n```python\r\nlinear = nn.Linear(768, 128)\r\nresult = linear(t)\r\n\r\nfq_linear = FakeQuantLinear(linear.weight.detach(), linear.bias.detach(), 8)\r\nprint('[fake quant] MSE loss', F.mse_loss(result, fq_linear(t)).item())\r\n\r\nact_scale = torch.max(t, dim=1).values\r\nsmooth_linear = SmoothQuantLinear(linear.weight.detach(), linear.bias.detach(), act_scale, 8)\r\nprint('[smooth quant] MSE loss', F.mse_loss(result, smooth_linear(t)).item())\r\n```\r\n```\r\n[fake quant] MSE loss 0.0059794094413518906\r\n[smooth quant] MSE loss 0.0003501520841382444\r\n```\r\n\r\n확실히 smooth quant의 방식이 기존 fake quant의 방식보다 더 적은 오차를 내는 것을 확인할 수 있네요.\r\n\r\n![](assets/smooth_quant/05.png)\r\n\r\n이는 위 텐서에 scale down을 적용한 모습입니다.\r\n적용하기 전보다 outlier 채널들의 값이 낮아진 것을 확인할 수 있어요.  \r\n\r\n![](assets/smooth_quant/06.png)\r\n\r\n물론 계산의 동등함을 유지하기 위해 weight에 scale up을 적용하여 위 채널과 연산에 관여하는 부분이 높아진 것을 확인할 수 있어요.\r\n하지만 이렇게 weight 범위가 늘어났다고 하여도, acitvation의 범위 감소율이 더 크기 때문에 전체 오차는 줄어들 수 있었습니다.  ","tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#review-of-quantization-difficulty","title":"Review of Quantization Difficulty"},{"url":"#smoothquant","title":"SmoothQuant"},{"url":"#implement","title":"Implement","items":[{"url":"#fakequant","title":"FakeQuant"},{"url":"#smoothquant-1","title":"SmoothQuant"}]}]},"frontmatter":{"description":"Accurate and Efficient Post-Training Quantization for Large Language Models","title":"SmoothQuant"}},"file":{"modifiedTime":"2023-12-11T16:10:21.160Z"}},"pageContext":{"id":"3202577a-3666-51a1-955d-6abc53c6c881","relativePath":"quantization/smooth_quant.mdx","frontmatter":{"title":"SmoothQuant","description":"Accurate and Efficient Post-Training Quantization for Large Language Models","order":2}}},"staticQueryHashes":["2317542362","3731189812"],"slicesMap":{}}