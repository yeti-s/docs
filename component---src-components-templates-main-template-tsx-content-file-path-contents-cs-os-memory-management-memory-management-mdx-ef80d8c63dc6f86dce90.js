"use strict";(self.webpackChunkyeti_docs=self.webpackChunkyeti_docs||[]).push([[8615],{7243:function(e,a,t){t.r(a),t.d(a,{default:function(){return S}});var n=t(1151),l=t(7294),i=t(93);function s(e){const a=Object.assign({p:"p",h1:"h1",code:"code",br:"br",h2:"h2",span:"span",math:"math",semantics:"semantics",mrow:"mrow",msup:"msup",mn:"mn",annotation:"annotation",mo:"mo"},(0,n.ah)(),e.components);return i||c("Elem",!1),i.ColorText||c("Elem.ColorText",!0),i.Cols||c("Elem.Cols",!0),i.Comment||c("Elem.Comment",!0),i.TwoCols||c("Elem.TwoCols",!0),l.createElement(l.Fragment,null,l.createElement(a.p,null,"메모리 관리는 운영 체제(OS)의 핵심 기능 중 하나로, 컴퓨터 시스템의 효율성과 성능을 극대화하는 데 필수적인 역할을 합니다.\r\n모든 컴퓨터 시스템은 제한된 메모리 자원을 가지고 있으며, 이를 효과적으로 관리하는 것은 다양한 프로그램과 응용 프로그램이 원활하게 작동할 수 있도록 보장합니다.\r\n운영 체제가 메모리를 어떻게 할당, 관리, 회수하는지에 대해 자세히 살펴볼 것이며, 이를 통해 운영 체제의 메모리 관리 전략의 중요성과 구체적인 메커니즘을 이해할 수 있습니다."),"\n",l.createElement(a.h1,{id:"address-binding"},"Address Binding"),"\n",l.createElement(a.p,null,l.createElement(a.code,null,"Logical Address")," 프로그램이 실행되는 동안 사용되는 가상의 주소 공간입니다.",l.createElement(a.br),"\n",l.createElement(a.code,null,"Physical Address")," 메모리 장치 내에 실제 데이터가 저장되는 위치입니다."),"\n",l.createElement(i.Comment,null,l.createElement(a.p,null,"Logical address는 보안과 메모리 사용의 유연성을 높이기 위함입니다.")),"\n",l.createElement(a.p,null,l.createElement("mark",null,"CPU가 프로세스의 작업을 실행하기 위해 논리 주소 만으로 실제 메모리의 주소를 알 수 없기 때문에 물리 주소를 맵핑하는 작업을")," ",l.createElement(a.code,null,"address binding"),"이라고 합니다."),"\n",l.createElement(a.p,null,"Address binding 시점으로 ",l.createElement(a.code,null,"compile time binding"),", ",l.createElement(a.code,null,"load time binding"),", ",l.createElement(a.code,null,"run time binding")," 세 가지로 나눌 수 있습니다."),"\n",l.createElement(a.h2,{id:"compile-time-binding"},"Compile Time Binding"),"\n",l.createElement(a.p,null,"말 그래도 컴파일 시 물리 주소가 결정되는 방식입니다.\r\n간단하게 말해서 프로그램 내부에서 사용하는 논리 주소와 물리 주소가 동일합니다.\r\n현재 우리가 사용하는 컴퓨터는 ",l.createElement(i.ColorText,{color:"var(--error)"},"한 가지 프로세스만 실행시키지 않기 때문에 이는 잘 사용되지 않는 방식입니다.")),"\n",l.createElement(a.h2,{id:"load-time-binding"},"Load Time Binding"),"\n",l.createElement(a.p,null,"프로세스가 실행될 때 물리 주소가 결정됩니다.\r\n프로세스가 로딩되는 위치에 따라 물리 주소를 맵핑하는 방식입니다.\r\n여러 프로세스를 동시에 실행시키는 멀티테스킹 환경에서 ",l.createElement(i.ColorText,{color:"var(--error)"},"프로세스가 메모리에 로드될 때 고정된 위치에 배치되어야 하므로 메모리 관리가 복잡합니다.")),"\n",l.createElement(a.h2,{id:"run-time-binding"},"Run Time Binding"),"\n",l.createElement(a.p,null,"프로세스가 실행한 후에도 물리적 주소가 변경될 수 있는 방식입니다.\r\nCPU가 주소를 참조할 때마다 해당 데이터가 물리 주소의 어느 위치에 있는지 ",l.createElement(a.code,null,"address mapping table"),"을 이용하여 binding 합니다."),"\n",l.createElement(a.h1,{id:"mmumamory-management-unit"},"MMU(Mamory Management Unit)"),"\n",l.createElement(a.p,null,l.createElement(a.code,null,"MMU"),"는 ",l.createElement("mark",null,"논리 주소를 물리 주소로 맵핑하기 위한 하드웨어 장치입니다."),"\r\n이는 ",l.createElement(a.code,null,"relocation register"),"와 ",l.createElement(a.code,null,"limit register"),"로 이루어졌습니다."),"\n",l.createElement(a.p,null,l.createElement(a.code,null,"Limit register"),"는 프로세스가 접근 가능한 논리 주소의 크기입니다.\r\n요청하는 논리 주소가 ",l.createElement(a.code,null,"limit register"),"보다 크면 OS에서 interrupt를 통해 프로세스를 종료합니다."),"\n",l.createElement(a.p,null,l.createElement(a.code,null,"Relocation register"),"는 프로세스가 접근할 수 있는 물리 주소의 최소값입니다.\r\n논리 주소에 ",l.createElement(a.code,null,"relocation register")," 값을 더하는 방법으로 물리 주소를 찾을 수 있습니다."),"\n",l.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<figure class="gatsby-resp-image-figure" style="">\n    <span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 704px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 69.31818181818181%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABg0lEQVR42q1Ua4+CQAzc///T/OSb6AkC8hIwSkQFEXoze7fkzD2i5po0uGw7nU6LSh60ruv0M0kSWa/XEgSBbDYb/buu6z5OPQto27bs93u5XC4ayPd9fTYx6rfk2+125wbQ87w7Rmma9oDfGJqkKIo0E1YngOM4fRLfl2UpTdNI27aSoHV7uZQsz2W324ki9fP5rFtgAM20QWBqlmWZhGGo74bDoVjzubgo4riuOIOBhJYl+eEgzfUqajwe6yQLL/kkKFmQQY6qp9NJF2QRGuPfwCjA2cdQ/NFIGjATdodcxUCCkK6LimSzWCy0bkVRyBVVCcg72nQ6FR8y5NBui9gYbMvJRGqcO5BQq9VKi8w1oMBGeEoQx7EuRJZcERrb9bAq6XYrMTyazT4YmqEwkGAGhGaGcDwe9QDYugGcA9CBJDE0DaFxBHYViLR/7SHBWICDMAvMtmnsKEerJYqReYJzAC8/7xVXxfgji/3UHn5N/slfBvz3T+/RPwc6B1hVVc/wHaQbNDAERAYCAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="MMU"\n        title=""\n        src="/static/bb75b3fca6aff5a9e7a6a00f848484c7/5ebd7/mmu.png"\n        srcset="/static/bb75b3fca6aff5a9e7a6a00f848484c7/06437/mmu.png 176w,\n/static/bb75b3fca6aff5a9e7a6a00f848484c7/ba1c3/mmu.png 352w,\n/static/bb75b3fca6aff5a9e7a6a00f848484c7/5ebd7/mmu.png 704w,\n/static/bb75b3fca6aff5a9e7a6a00f848484c7/5bf79/mmu.png 966w"\n        sizes="(max-width: 704px) 100vw, 704px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>\n    <figcaption class="gatsby-resp-image-figcaption">MMU</figcaption>\n  </figure>'}}),"\n",l.createElement(a.p,null,"위 그림에서 논리 주소 346를 요청했을 때, ",l.createElement(a.code,null,"relocation register")," + 논리 주소 인 14346의 값을 읽어 전달합니다.\r\n이렇듯 ",l.createElement(a.code,null,"MMU"),"는 context switching이 발생할 때 ",l.createElement(a.code,null,"relocation register")," 값을 바꿔주며 address binding을 할 수 있습니다."),"\n",l.createElement(a.h1,{id:"fragmentation"},"Fragmentation"),"\n",l.createElement(a.p,null,"사실 앞서 소개한 방법은 연속적인 시퀀스를 통채로 메모리에 올리는 방법입니다.\r\n이러한 방식은 몇 가지 문제를 야기할 수 있습니다."),"\n",l.createElement(a.h2,{id:"external-fragmentation"},"External Fragmentation"),"\n",l.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<figure class="gatsby-resp-image-figure" style="">\n    <span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 634px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 54.545454545454554%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB3UlEQVR42pWSS2/TUBCF/ZNZwA4WLNu/wBIW/ACEYFGBhNQHUJI6ap04sWMn8SN2YjvxK7GdfFxfiNSWgMSRru7M1ejMzDlX2e/31LuGHXtxkLfMxftjtLVp1RCkOV6c4Mcrkm3Nelux2+1kjXKdTnjhfuTpxWuenL3i2cUbnjsf+JbasuBAXNc1m82GZVkxdOd0NB11NMZLC4K8pKp+kSpqOuM0+MSJ9o6Xl2851d9z4p/RTacPCLMswzAM7PGYiW1hmgau6zA2TSzxZlkWeZ6jlFXNIq+YBBGm6DxbxMRlQyFWu4+maUiShPl8znA4Quv36fV6qKpKEASsVispiRKu1vRmHpe3fb50VL72h2hegLtY0og1j+GgV9vkEB+gRGL/YZzx3bA5v9P5YU4YJTnhOifPUrbb7QNT7sePjyQMhVu9sU3PsOjqhhT61prgzAPKoiCOY7lqi9aUdrVWz79BiYsNRrrl2nI47xt0pz5mVgkdq3YMCkFq2zZhGEpTNE1D13XZ6CjhUmg4cHwx1VROd2fP0IWG/iKSrkVRRFmWUqs2b6ds8/Y+TphmDMKEK2HG584NV4MR+mLFPFn/1rD6Q79/QVmnKVPPY+Z62NMZU8fF8X0W0VJ+5v/FT/XTQudVddNqAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="External Fragmentation"\n        title=""\n        src="/static/12eb0e8af7aa3bc20857d187c9ac70e3/374ac/external_fragmentation.png"\n        srcset="/static/12eb0e8af7aa3bc20857d187c9ac70e3/06437/external_fragmentation.png 176w,\n/static/12eb0e8af7aa3bc20857d187c9ac70e3/ba1c3/external_fragmentation.png 352w,\n/static/12eb0e8af7aa3bc20857d187c9ac70e3/374ac/external_fragmentation.png 634w"\n        sizes="(max-width: 634px) 100vw, 634px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>\n    <figcaption class="gatsby-resp-image-figcaption">External Fragmentation</figcaption>\n  </figure>'}}),"\n",l.createElement(a.p,null,"위 그림은 같이 여러 프로세스가 실행되고 종료된 상황입니다.\r\n연속적인 크기로 메모리를 할당한다면 적은 메모리를 사용하던 프로세스가 종료되면 다음과 같이 비어있는 공간 ",l.createElement(a.code,null,"hole"),"이 생깁니다.\r\n이때 만약 모든 ",l.createElement(a.code,null,"hole"),"보다 큰 메모리 사용량을 가지는 프로세스가 실행되었을 때, 메모리 할당 공간이 부족해서 프로세스는 대기하게 됩니다.\r\n",l.createElement("mark",null,"충분한 메모리 공간이 파편화 되어 있어 프로세스가 실행되지 못하는 현상을")," ",l.createElement(a.code,null,"external fragmentation"),"라고 합니다."),"\n",l.createElement(a.h2,{id:"compaction"},"Compaction"),"\n",l.createElement(a.p,null,l.createElement(a.code,null,"External fragmentation")," 문제를 해결하기 위해 필요한 메모리 공간만큼 사용 중인 메모리 공간들을 정리하여 자리를 만들어주면 됩니다."),"\n",l.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<figure class="gatsby-resp-image-figure" style="">\n    <span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 582px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 82.38636363636364%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3VBR/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAFxABAQEBAAAAAAAAAAAAAAAAAAEREP/aAAgBAQABPyFupyo//9oADAMBAAIAAwAAABDTD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAAMAAgMBAAAAAAAAAAAAAAABESGBMUFx8P/aAAgBAQABPxCKNzexo8RjfSPiP5iOrB2qP//Z\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Compaction"\n        title=""\n        src="/static/c5e4fb9fb1fe510171aba9b20c073450/14007/compaction.jpg"\n        srcset="/static/c5e4fb9fb1fe510171aba9b20c073450/a5658/compaction.jpg 176w,\n/static/c5e4fb9fb1fe510171aba9b20c073450/e5a29/compaction.jpg 352w,\n/static/c5e4fb9fb1fe510171aba9b20c073450/14007/compaction.jpg 582w"\n        sizes="(max-width: 582px) 100vw, 582px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>\n    <figcaption class="gatsby-resp-image-figcaption">Compaction</figcaption>\n  </figure>'}}),"\n",l.createElement(a.p,null,"이러한 방법은 프로세스를 저장소(SSD, HDD)에 복사한 후 다시 가져와 연속된 빈 공간을 만들어내는 방식이죠.\r\n하지만 ",l.createElement(i.ColorText,{color:"var(--error)"},"복사 후 가져오는 과정은 큰 overhead를 발생시키는 문제가 있습니다.")),"\n",l.createElement(a.h1,{id:"paging"},"Paging"),"\n",l.createElement(a.p,null,l.createElement(a.code,null,"page")," 논리 주소를 여러 개로 나눈 단위",l.createElement(a.br),"\n",l.createElement(a.code,null,"frame")," 물리 주소를 여러 개로 나눈 단위"),"\n",l.createElement(i.TwoCols,{align:"center"},l.createElement(i.Cols,{size:45},l.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<figure class="gatsby-resp-image-figure" style="">\n    <span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 704px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 90.9090909090909%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsTAAALEwEAmpwYAAABt0lEQVR42pWSbU+jQBSF5///GL+4dluVwpaXqHVNdAsMMANlCpQCKcq7RWApbpTWjSknhExu5sk5984FzWmq63q5NCRJKoriowjyLI+iuP2SJP0K9M6VbVuGYQThS5gW2ziLswKYJhmNJlfXtCTDr3ZNVR1U3naPdjjbVKzXLPx8DzMMyws3MlQO7lVv0PIlZ/tZ6ILIxOVUh9fWounu4fMfI2rKyFD9tOx+v/U1q7lHXSiyfH52NrkYyaL4f+cOrh50h1edfhOt4GrDyBbXOhMPELL6Ob7snI9il3fI5pF3VHyytrxfC0Gz8DJgGMuW/DXjFqLUj1fkOSKOYjpJkvTiNLKKKfaGFuaigoBl2dMpwwu3GsJ9OAzDFSHeeh34wUHPijoZX9I0AxUFlGWJEdY0LU2zU7YFSpC6orgZC6ECdq+vGCGMcdzF+1iMuqe+M9TJmJvT939EbIJ/c+xd+k7twOxtO639wPwMNCfr/fFF55kyIoYkT87LALhbz/KRBJy7493dYpMMcX5fEmRcc3Pm9kFU9UHwntZ1g6ZogReQhgfDURS1j4MQCsPnwXCapGorRY2i+C9sAfzW9fI9zAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Page &amp; Frame"\n        title=""\n        src="/static/dc6f7acab3b7d6bdd8246a5fa1aa587b/5ebd7/page_frame.png"\n        srcset="/static/dc6f7acab3b7d6bdd8246a5fa1aa587b/06437/page_frame.png 176w,\n/static/dc6f7acab3b7d6bdd8246a5fa1aa587b/ba1c3/page_frame.png 352w,\n/static/dc6f7acab3b7d6bdd8246a5fa1aa587b/5ebd7/page_frame.png 704w,\n/static/dc6f7acab3b7d6bdd8246a5fa1aa587b/73b94/page_frame.png 1004w"\n        sizes="(max-width: 704px) 100vw, 704px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>\n    <figcaption class="gatsby-resp-image-figcaption">Page &amp; Frame</figcaption>\n  </figure>'}})),l.createElement(i.Cols,{size:50},l.createElement(a.p,null,"앞선 문제들은 결국 연속적인 메모리 할당으로 인해 발생하였습니다.\r\n이를 ",l.createElement("mark",null,"페이지와 프레임을 이용하여 연속적이지 않은 형태로 저장하는 방법을 "),l.createElement(a.code,null,"paging"),"이라고 합니다.\r\n이때 페이지와 프레임은 모두 동일한 크기로 나누어야 합니다."),l.createElement(a.p,null,"위 그림과 같이 작은 단위로 메모리를 사용할 수 있고 이를 ",l.createElement(a.code,null,"page table"),"을 이용하여 논리 주소에서 물리 주소를 알아낼 수 있습니다.\r\n이러한 방법으로 ",l.createElement(i.ColorText,{color:"var(--info)"},l.createElement(a.code,null,"external fragmentation")," 문제를 해결할 수 있습니다.")))),"\n",l.createElement(a.h2,{id:"page-table"},"Page Table"),"\n",l.createElement(a.p,null,l.createElement(a.code,null,"Page table"),"을 이용하여 물리 주소를 찾는 과정을 조금 더 자세히 바라보겠습니다.\r\n",l.createElement(a.span,{className:"math math-inline"},l.createElement(a.span,{className:"katex"},l.createElement(a.span,{className:"katex-mathml"},l.createElement(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(a.semantics,null,l.createElement(a.mrow,null,l.createElement(a.msup,null,l.createElement(a.mn,null,"2"),l.createElement(a.mn,null,"32"))),l.createElement(a.annotation,{encoding:"application/x-tex"},"2^{32}")))),l.createElement(a.span,{className:"katex-html","aria-hidden":"true"},l.createElement(a.span,{className:"base"},l.createElement(a.span,{className:"strut",style:{height:"0.8141em"}}),l.createElement(a.span,{className:"mord"},l.createElement(a.span,{className:"mord"},"2"),l.createElement(a.span,{className:"msupsub"},l.createElement(a.span,{className:"vlist-t"},l.createElement(a.span,{className:"vlist-r"},l.createElement(a.span,{className:"vlist",style:{height:"0.8141em"}},l.createElement(a.span,{style:{top:"-3.063em",marginRight:"0.05em"}},l.createElement(a.span,{className:"pstrut",style:{height:"2.7em"}}),l.createElement(a.span,{className:"sizing reset-size6 size3 mtight"},l.createElement(a.span,{className:"mord mtight"},l.createElement(a.span,{className:"mord mtight"},"32"))))))))))))),"bit의 논리 메모리를 가지고, 페이지의 크기가 ",l.createElement(a.span,{className:"math math-inline"},l.createElement(a.span,{className:"katex"},l.createElement(a.span,{className:"katex-mathml"},l.createElement(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(a.semantics,null,l.createElement(a.mrow,null,l.createElement(a.msup,null,l.createElement(a.mn,null,"2"),l.createElement(a.mn,null,"12"))),l.createElement(a.annotation,{encoding:"application/x-tex"},"2^{12}")))),l.createElement(a.span,{className:"katex-html","aria-hidden":"true"},l.createElement(a.span,{className:"base"},l.createElement(a.span,{className:"strut",style:{height:"0.8141em"}}),l.createElement(a.span,{className:"mord"},l.createElement(a.span,{className:"mord"},"2"),l.createElement(a.span,{className:"msupsub"},l.createElement(a.span,{className:"vlist-t"},l.createElement(a.span,{className:"vlist-r"},l.createElement(a.span,{className:"vlist",style:{height:"0.8141em"}},l.createElement(a.span,{style:{top:"-3.063em",marginRight:"0.05em"}},l.createElement(a.span,{className:"pstrut",style:{height:"2.7em"}}),l.createElement(a.span,{className:"sizing reset-size6 size3 mtight"},l.createElement(a.span,{className:"mord mtight"},l.createElement(a.span,{className:"mord mtight"},"12"))))))))))))),"bit 라고 한다면, 페이지 테이블의 크기는 ",l.createElement(a.span,{className:"math math-inline"},l.createElement(a.span,{className:"katex"},l.createElement(a.span,{className:"katex-mathml"},l.createElement(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML"},l.createElement(a.semantics,null,l.createElement(a.mrow,null,l.createElement(a.msup,null,l.createElement(a.mn,null,"2"),l.createElement(a.mn,null,"20")),l.createElement(a.mo,null,"⋅"),l.createElement(a.mn,null,"4")),l.createElement(a.annotation,{encoding:"application/x-tex"},"2^{20} \\cdot 4")))),l.createElement(a.span,{className:"katex-html","aria-hidden":"true"},l.createElement(a.span,{className:"base"},l.createElement(a.span,{className:"strut",style:{height:"0.8141em"}}),l.createElement(a.span,{className:"mord"},l.createElement(a.span,{className:"mord"},"2"),l.createElement(a.span,{className:"msupsub"},l.createElement(a.span,{className:"vlist-t"},l.createElement(a.span,{className:"vlist-r"},l.createElement(a.span,{className:"vlist",style:{height:"0.8141em"}},l.createElement(a.span,{style:{top:"-3.063em",marginRight:"0.05em"}},l.createElement(a.span,{className:"pstrut",style:{height:"2.7em"}}),l.createElement(a.span,{className:"sizing reset-size6 size3 mtight"},l.createElement(a.span,{className:"mord mtight"},l.createElement(a.span,{className:"mord mtight"},"20"))))))))),l.createElement(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),l.createElement(a.span,{className:"mbin"},"⋅"),l.createElement(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})),l.createElement(a.span,{className:"base"},l.createElement(a.span,{className:"strut",style:{height:"0.6444em"}}),l.createElement(a.span,{className:"mord"},"4"))))),"bytes, 즉 4MB 입니다.\r\n만약 프로세스가 10개가 되면 페이지 테이블의 크기만 총 40MB가 되고 성능에 문제가 발생하죠.\r\n이를 해결하기 위해 다양한 방법이 존재합니다."),"\n",l.createElement(a.h2,{id:"multi-level-paginig"},"Multi-level paginig"),"\n",l.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<figure class="gatsby-resp-image-figure" style="">\n    <span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 704px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 48.86363636363636%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB2UlEQVR42nWRS2/TQBSF/Zf5C2y6qIS6gA3s2ICoKhUJJFoRVXm2ImmIG8d2AkmcceLnPDx+jT3jB9MsIoTEWd3FPed+914lGAxQr+98u1l0xlpfW/Q1UweGaei6nmVZ27ZN07T/kWJ3e3TyiKc/wQ5Nn3brLd5aoWEY3W73cDgghIIgCI/yfb8oCoFQZtvMdQvXVTAhOE89AjOWuq5b17WMZIwRQiCESZJkaZImMWO553myoa0aY77V1A0OqUIQzmEWe5TH3Ab7+ijHcQAAcqYQ4kQug8IgkMUPdT+a7gPMlCVY9nBvGMnVB/pvs6nbKIqkWUI6rhsc9mj0Hd134PDWvB/NdSMnaHX59teH12Q5U0zPPNudnTvnF87FQFXXqwQimKYppXRjWdA7rL++Nz698TofZw/98XQG7a357uX81Qv6NFREKXjE27ytkwrsQFkWESG5XDSmkjwMIXB9VvIj/POFRdXoG7RYR4gWSlEWEMM4jUlMLMviQsQFL5qW1e1MVSeTccnLZ2ddNU3dHJVQiiAUnCvyPGVZci5dAth7a2XsOpd+/xrcXd18+QwR+ufVVVVrGpipluRT/n66TI5C3364Dad3zriDfLc94Z566gbjGOOUMf4HgTAgewRxjbsAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Multi-Level Paging"\n        title=""\n        src="/static/0a7b479ad9f90ab9dd81bd7efeefc9ca/5ebd7/multi_level_paging.png"\n        srcset="/static/0a7b479ad9f90ab9dd81bd7efeefc9ca/06437/multi_level_paging.png 176w,\n/static/0a7b479ad9f90ab9dd81bd7efeefc9ca/ba1c3/multi_level_paging.png 352w,\n/static/0a7b479ad9f90ab9dd81bd7efeefc9ca/5ebd7/multi_level_paging.png 704w,\n/static/0a7b479ad9f90ab9dd81bd7efeefc9ca/e9beb/multi_level_paging.png 730w"\n        sizes="(max-width: 704px) 100vw, 704px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>\n    <figcaption class="gatsby-resp-image-figcaption">Multi-Level Paging</figcaption>\n  </figure>'}}),"\n",l.createElement(a.p,null,l.createElement(a.code,null,"Multi-level paging"),"은 여러 단계의 레이어를 거쳐 물리 주소를 찾는 방법입니다.\r\n",l.createElement(i.ColorText,{color:"var(--info)"},"모든 페이지 테이블을 들고 다니지 않아도 되기 때문에 메모리 문제가 덜하지만"),",\r\n",l.createElement(i.ColorText,{color:"var(--error)"},"레이어가 많아짐에 따라 메모리 접근에 대한 overhead가 발생합니다.")),"\n",l.createElement(a.h2,{id:"hashed-page-table"},"Hashed Page Table"),"\n",l.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<figure class="gatsby-resp-image-figure" style="">\n    <span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 527px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 53.40909090909091%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABwUlEQVR42pVS2XKbQBDk/78lP5DX2HLiikuyIxHrwiBFhjULCMS5B7R3VqIi+ynpqqmhBqanpwenrmu0bQspJfq+hzK5EwLCBNU+B31DqEzfer1C+BZjzhs8sBrbOIfDOYfrupg9PmGxcJFlGWhIWZYfoqoqHI9HrDcb/JrPsVyuEAQ+dq8RfsQS33iPBSvg0DSeJPD9AMxMsyqGAfqi5BpDP2C332PreYh5YrdJ8gLfWYsJ13CJcDDNRHIyKgi1kPjJKvxOGmitQO8pxlXJHtpgRC0U7mOB25GQilIKFEVhPyg7Iz9WmKXKElplF1JC0zR2/RFlK3DPFe4ynFcWusf8wHHzHCBrJMq6wcTneDxk9jBd10EphTRNLRGpo+Ha9Nkjmrz884bpZgd2PMEpGoGv7h5fHtZYsgwsinA3X2H67CEx3kZhhNfDAZ7xjY4XhiEC38eL92IHEmLG4HtbM7y9eKg0WqloN9Qm37AOs0QYBfqDh6fyZAlIdZ7n9pnqox2Unf7SMBYrc5SJMfkpleej9GeysXEY81Vcv3f+Fs+EZdPi1ng4PaTGO4nh6ij/Es7nf43W4XGMxPzwWmv8L94BCgROKtxJs2EAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Hashed Page Table"\n        title=""\n        src="/static/7ebb6aa78f5fa1859ba0dc1d544b8ebc/44385/hashed_page_table.png"\n        srcset="/static/7ebb6aa78f5fa1859ba0dc1d544b8ebc/06437/hashed_page_table.png 176w,\n/static/7ebb6aa78f5fa1859ba0dc1d544b8ebc/ba1c3/hashed_page_table.png 352w,\n/static/7ebb6aa78f5fa1859ba0dc1d544b8ebc/44385/hashed_page_table.png 527w"\n        sizes="(max-width: 527px) 100vw, 527px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>\n    <figcaption class="gatsby-resp-image-figcaption">Hashed Page Table</figcaption>\n  </figure>'}}),"\n",l.createElement(a.p,null,"주소 공간이 32bit보다 크면 가상 페이지 번호가 되는 ",l.createElement(a.code,null,"hashed page table"),"을 많이 사용합니다.\r\n논리 주소 공간의 페이지 번호인 p를 hash를 이용한 결과값으로 테이블을 검색한 후 해당 물리 메모리를 찾아갑니다."),"\n",l.createElement(a.h2,{id:"internal-fragmentation"},"Internal Fragmentation"),"\n",l.createElement(a.p,null,"앞서 동일한 크기의 페이지와 프레임을 이용하여 ",l.createElement(a.code,null,"external fragmentation")," 문제를 해결했습니다.\r\n하지만 메모리의 크기가 페이지의 크기에 맞춰 나누어 떨어지지 않을 수 있습니다.\r\n이러한 경우 ",l.createElement("mark",null,"페이지 내부에 빈 공간이 발생하는 것을")," ",l.createElement(a.code,null,"internal fragmentation"),"이라 합니다."),"\n",l.createElement(a.h1,{id:"tlbtranslation-look-aside-block"},"TLB(Translation Look-aside Block)"),"\n",l.createElement(a.p,null,"페이지 테이블을 어디에 저장해야 가장 빠르게 참조할 수 있을까요?\r\n",l.createElement(a.code,null,"MMU"),"는 4MB가 되는 페이지 테이블을 저장할 수 없습니다.\r\n또한 페이지 테이블을 메모리에 저장한다면 메모리에 접근하기 위해 메모리를 접근하는, 2번의 접근 과정이 필요합니다."),"\n",l.createElement(a.p,null,"사실 페이지 테이블은 크기가 크지만 모두 다 사용되는 것은 아닙니다.\r\n프로그램은 ",l.createElement(a.code,null,"locality")," ",l.createElement("mark",null,"라는 특성을 가지고 있어 자주 쓰이는 녀석은 자주 쓰이고 안쓰이는 녀석은 거의 안쓰입니다."),"\r\n이를 이용하여 캐시 메모리에 페이지 테이블을 저장하려고 합니다."),"\n",l.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<figure class="gatsby-resp-image-figure" style="">\n    <span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 582px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 73.86363636363636%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACQElEQVR42o2UCW/aQBCF+f9/CKVtWtpyNLSJVI5gbAi+weD7wgfwOrMUREhQO9LK1+7nN29mt7HZuDBNG57nwzQM2JYFjrqu3x1VVWG/3+NWNJ4nEu4/tzAeTzD4PUCv24Msy0jTFFmaIcsycS+e6T6KIoRhKBYfDgd4WYF1WsJJSqRFhYY0lfG904MkydB1HYoyI8UWyrLEbrcTii6D1TGcg7//XGZoOzW+rSqofo4Gp2rbSwRBiMD3sd1uoWkaRqMRNFXDcDAUC4+KjhAGsjq24NHJ0d3s0F7XUEMCnqRzcCpTUtxfOOipLh5o9A0fQZJjTyCex8AkSc4KH53sNZBZJ4/jOEa708WHiYW7uYc7ZYN7NYSimZgrMhzHERYEQYCZokBdLASwd63wFGVRYDR+RnNsoilvBLCpuFhHmfjOymRZEUWTpSkM3SAPU/TcG8A8zxFQ2nqQQrJdDBYWtCBDXhwLE0UxhsMRVPKWO4D97lvxbSC3BRst/KHrln5w8qrmQe+SODnPP3r4TlHOCgm4+wsULUIL3DDBE/nUX+VYhdSXSYzDfwNJEafB1eYCVdSLjh/iqx7hExXH9BPk6WuFT6LKNQEraNfAgorieZ7YfsvlknxKYK1dtBY+vmgR5isXJf3wEviLlP/wD2i7e6jBFfAyTmnFVJCWFuLjIsQy3uKybzkcsmT8YkA2VsjK6i2QJ5+GaBUCPtgxOmYMJ87fAAtSPJtOYdHBIg4H/CN4T2u0x+cv6nmHXAIPV1n9AR6YeKCe0T+1AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="TLB"\n        title=""\n        src="/static/c86c979dee867c7594727afd76ea703d/7c1cd/tlb.png"\n        srcset="/static/c86c979dee867c7594727afd76ea703d/06437/tlb.png 176w,\n/static/c86c979dee867c7594727afd76ea703d/ba1c3/tlb.png 352w,\n/static/c86c979dee867c7594727afd76ea703d/7c1cd/tlb.png 582w"\n        sizes="(max-width: 582px) 100vw, 582px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>\n    <figcaption class="gatsby-resp-image-figcaption">TLB</figcaption>\n  </figure>'}}),"\n",l.createElement(a.p,null,"가상주소가 주어지면 이를 ",l.createElement(a.code,null,"TLB"),"에서 확인을 합니다.\r\n",l.createElement(a.code,null,"TLB"),"에 가상주소가 존재하면",l.createElement(a.code,null,"(TLB hit)")," 프레임 번호를 추출하여 오프셋과 물리 주소를 구성합니다.\r\n",l.createElement(a.code,null,"TLB"),"에 가상주소가 존재하지 않으면",l.createElement(a.code,null,"(TLB miss)")," 페이지 테이블로 가서 프레임 번호를 얻어 오프셋과 물리 주소를 구성합니다."),"\n",l.createElement(a.h1,{id:"segmentation"},"Segmentation"),"\n",l.createElement(a.p,null,"일정단 단위로 나누어 저장하는 ",l.createElement(a.code,null,"paging")," 방법에도 문제가 있습니다.\r\n프로세스의 메모리는 code, data, stack, heap 영역으로 구성되어 있는데 페이지를 통해 나누면 여러 영역이 섞일 수 있다는 문제가 있습니다.\r\n따라서 이를 아주 간단하게는 code, data, stack & heap 처럼 ",l.createElement("mark",null,"영역별로 나누어 저장하는")," ",l.createElement(a.code,null,"segmentation")," 방식이 등장합니다."),"\n",l.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<figure class="gatsby-resp-image-figure" style="">\n    <span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 704px; "\n    >\n      <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 53.40909090909091%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXElEQVR42nWRiW6DMBBE8/+f1qoRDYRQiyOADZiAjQ/uFLoBKU1IO8IrZHbGb81uXjRNE9Qsy0zT1FK2CHUINb6/fJrvPXVdzw/awbper+M4wuqHATqlUh+GYTrO/nD4XtS27TAMTdNgjKH5yQzOoijSNNO8lBQrKT8N48txnJNdVhqnuU9PZvDuURsncdO0d9Kbue97iAyjSLJy1FWttWVZCCH7eBS65UJXuuDwqEvXd1tsiAG2ta5ZcRwTQsIwhB0AvvAszfGFZUlCuq57Mt8xXgVmGDUpooAgqJ7vKqWesDeaFmmtgRxahRA+tc3zm5/bYXxeL/xfM9jAUxYlpVTCb2sbUgQesaPc5YLBfFvsR3jGmFAVvWRlVXDOIYgKjEsv5WGEo3XmP05et0QloiRw8SlIEa9Y33fwYrl7lzj98HLbG0G2VOLLcxJK6lpDopKKlQxCb5cx/2L/ADyYdRB5Cdx4AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Segmentation"\n        title=""\n        src="/static/03b8745190392ef1b364cf91920cc96d/5ebd7/segmentation.png"\n        srcset="/static/03b8745190392ef1b364cf91920cc96d/06437/segmentation.png 176w,\n/static/03b8745190392ef1b364cf91920cc96d/ba1c3/segmentation.png 352w,\n/static/03b8745190392ef1b364cf91920cc96d/5ebd7/segmentation.png 704w,\n/static/03b8745190392ef1b364cf91920cc96d/906b5/segmentation.png 950w"\n        sizes="(max-width: 704px) 100vw, 704px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n    </span>\n    <figcaption class="gatsby-resp-image-figcaption">Segmentation</figcaption>\n  </figure>'}}),"\n",l.createElement(a.p,null,l.createElement(a.code,null,"Segment Table"),"에서는 각 segment에 대한 기본 주소와 크기를 가지고 있습니다.\r\n오프셋과 리밋을 이용하여 초과된 메모리를 가르키는지 확인하고, 기본값과 오프셋을 이용해 물리 주소를 파악할 수 있습니다.\r\n이러한 방법은 ",l.createElement(i.ColorText,{color:"var(--info)"},"여러 영역이 섞이지 않게 하는 보호",l.createElement(a.code,null,"(protection)")," 기능을 합니다."),"\r\n같은 프로그램을 여러 프로세스가 사용한다면 ",l.createElement(i.ColorText,{color:"var(--info)"},"동일한 세그먼트를 공유하도록 하여 메모리를 절약할 수도 있습니다."),"\r\n또한 ",l.createElement(i.ColorText,{color:"var(--info)"},"고정된 영역이 아니기 때문에 영역내 빈 공간이 발생하는 ",l.createElement(a.code,null,"internal fragmentation"),"이 발생하지 않습니다."),"\r\n하지만 ",l.createElement(i.ColorText,{color:"var(--error)"},"세그먼트의 크기가 고정적이지 않고 가변적이기 때문에 ",l.createElement(a.code,null,"external fragmentation"),"이 발생할 수 있습니다.")),"\n",l.createElement(a.h1,{id:"paging--segmentation"},"Paging + Segmentation"),"\n",l.createElement(a.p,null,"서로의 장점만을 이용하기 위해 ",l.createElement(a.code,null,"paging"),"과 ",l.createElement(a.code,null,"segmentation"),"을 결합하여 사용하는 방법이 등장하였습니다.\r\n하나의 segment를 page로 쪼개어 저장하는 방식으로 ",l.createElement(a.code,null,"external fragmentation"),"을 해결할 수 있습니다.\r\n하지만 ",l.createElement(i.ColorText,{color:"var(--error)"},"테이블을 두번 참조해야 하기 때문에 상대적으로 큰 오버헤드가 발생합니다.")))}var r=function(e){void 0===e&&(e={});const{wrapper:a}=Object.assign({},(0,n.ah)(),e.components);return a?l.createElement(a,e,l.createElement(s,e)):s(e)};function c(e,a){throw new Error("Expected "+(a?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}var m=t(4316),o=t(1840),g=t(7821),A=t(2654),d=t(4111),p=t(2726),b=t(4480),E=t(2818),u=t(9213),f=t(7213),h=t(9265),w=t(9601),y=t(3071),x=t(6097),B=t(6782),v=t(4891),N=t(3387),C=t(917);const k=e=>{let{data:{mdx:a},children:t}=e;const i=(0,b.sJ)((0,E.cp)(E.eE,!1)),s=(0,b.sJ)((0,E.cp)(E.rf,!1)),r=(0,b.Zl)((0,E.cp)(E.Cy,a.tableOfContents.items));return(0,l.useEffect)((()=>{r(a.tableOfContents.items)}),[a]),(0,C.tZ)(o.Z,null,(0,C.tZ)(M,null,(0,C.tZ)(d.Z,null)),(0,C.tZ)(Q,null,(0,C.tZ)(T,{className:"navigation",isNavOpened:s},(0,C.tZ)(R,{className:"hide_scroll"},(0,C.tZ)(g.Z,null))),(0,C.tZ)(Y,{isNavOpened:s},(0,C.tZ)(j,{isWide:i},(0,C.tZ)(p.Z,{title:a.frontmatter.title,date:a.frontmatter.date}),(0,C.tZ)(n.Zo,{components:{p:f.Z,h1:h.H1,h2:h.H2,h3:h.H3,h4:h.H4,h5:h.H5,h6:h.H6,hr:w.Z,blockquote:y.Z,ul:B.Z,ol:x.Z,pre:v.Z,code:N.Z}},t))),(0,C.tZ)(P,null,(0,C.tZ)(z,null,(0,C.tZ)(A.Z,null)))))},M=(0,m.Z)("div",{target:"e1ojob7j7"})({name:"11t2x7x",styles:"display:flex;height:var(--header-height);z-index:5;padding:0.6rem 2rem 0.6rem 0.6rem;position:fixed;width:100%;background:var(--background-color);border-bottom:1px solid var(--border-color)"}),Q=(0,m.Z)("div",{target:"e1ojob7j6"})({name:"majwgz",styles:"position:relative;display:flex;min-height:calc(100vh - var(--header-height));overflow-x:hidden"}),T=(0,m.Z)("aside",{target:"e1ojob7j5"})("margin-left:",(e=>e.isNavOpened?"0":"calc(-1 * var(--sidebar-width))"),";flex:0 0 var(--sidebar-width);font-size:0.875rem;overflow-x:hidden;overflow-y:auto;transition:margin 0.25s var(--ease-in-out-quad);@media (min-width: ",u.Z.IPAD_PRO,"px){margin-left:0;}"),R=(0,m.Z)("nav",{target:"e1ojob7j4"})({name:"l4vzaw",styles:"overflow-y:auto;height:100%;padding:var(--body-padding-top) 0 3rem 0;position:fixed;width:var(--sidebar-width);&:-webkit-scrollbar{display:none;}"}),j=(0,m.Z)("main",{target:"e1ojob7j3"})("padding:1rem;width:100%;@media (min-width: ",u.Z.IPAD_AIR,"px){width:",(e=>e.isWide?"90%":"65%"),";}"),Y=(0,m.Z)("main",{target:"e1ojob7j2"})("width:calc(100% - 2 * var(--sidebar-width));padding-top:var(--body-padding-top);flex-grow:1;min-width:20rem;display:flex;justify-content:center;opacity:",(e=>e.isNavOpened?.3:1),";@media (min-width: ",u.Z.IPAD_PRO,"px){opacity:1;}"),P=(0,m.Z)("aside",{target:"e1ojob7j1"})("font-size:0.75rem;font-weight:bold;overflow-x:hidden;overflow-y:auto;padding-top:var(--body-padding-top);width:0;transition:width 0.25s var(--ease-in-out-quad);@media (min-width: ",u.Z.HD,"px){width:var(--sidebar-width);}"),z=(0,m.Z)(R,{target:"e1ojob7j0"})({name:"b40oxt",styles:"padding:0 1rem 0 1rem"});function S(e){return l.createElement(k,e,l.createElement(r,e))}}}]);
//# sourceMappingURL=component---src-components-templates-main-template-tsx-content-file-path-contents-cs-os-memory-management-memory-management-mdx-ef80d8c63dc6f86dce90.js.map